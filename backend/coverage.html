
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>handlers: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">auction/api/handlers/auction_handlers.go (75.5%)</option>
				
				<option value="file1">auction/api/handlers/bidder_handlers.go (47.7%)</option>
				
				<option value="file2">auction/api/middleware/middleware.go (100.0%)</option>
				
				<option value="file3">auction/api/middleware/rate_limiter.go (80.0%)</option>
				
				<option value="file4">auction/config/config.go (100.0%)</option>
				
				<option value="file5">auction/internal/database/tiny_db.go (77.2%)</option>
				
				<option value="file6">auction/internal/models/errors.go (0.0%)</option>
				
				<option value="file7">auction/internal/services/excel_service.go (78.8%)</option>
				
				<option value="file8">auction/main.go (0.0%)</option>
				
				<option value="file9">auction/tests/mock_database.go (56.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package handlers

import (
        "log"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"

        "auction/internal/database"
        "auction/internal/models"
)

// AuctionHandlers handles auction-related API endpoints
type AuctionHandlers struct {
        db     database.Database
        logger *log.Logger
}

// NewAuctionHandlers creates a new instance of AuctionHandlers
func NewAuctionHandlers(db database.Database, logger *log.Logger) *AuctionHandlers <span class="cov8" title="1">{
        return &amp;AuctionHandlers{
                db:     db,
                logger: logger,
        }
}</span>

// Request and response types for the API
type CreateAuctionRequest struct {
        Title         string          `json:"title" binding:"required"`
        StartingPrice int             `json:"startingPrice" binding:"required"`
        PriceStep     int             `json:"priceStep" binding:"required"`
        Bidders       []models.Bidder `json:"bidders"`
}

type AuctionResponse struct {
        ID            string          `json:"id"`
        Title         string          `json:"title"`
        Status        string          `json:"status"`
        CurrentRound  int             `json:"currentRound"`
        StartingPrice int             `json:"startingPrice"`
        PriceStep     int             `json:"priceStep"`
        HighestBid    int             `json:"highestBid"`
        HighestBidder string          `json:"highestBidder"`
        CreatedAt     time.Time       `json:"createdAt"`
        Bidders       []models.Bidder `json:"bidders"`
}

// CreateAuction creates a new auction
func (h *AuctionHandlers) CreateAuction(c *gin.Context) <span class="cov8" title="1">{
        var req CreateAuctionRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                h.logger.Printf("Error binding create auction JSON: %v", err)
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">h.logger.Printf("Received create auction request: Title=%s, StartingPrice=%d, PriceStep=%d",
                req.Title, req.StartingPrice, req.PriceStep)

        // Generate a unique ID for the auction
        auctionID := uuid.New().String()

        // Create new auction
        auction := &amp;models.Auction{
                ID:            auctionID,
                Title:         req.Title,
                CreatedAt:     time.Now(),
                StartingPrice: req.StartingPrice,
                PriceStep:     req.PriceStep,
                Bidders:       req.Bidders,
                BidHistory:    []models.Bid{},
                CurrentRound:  0,
                HighestBid:    0,
                HighestBidder: "",
                AuctionStatus: "notStarted",
        }

        // Save the auction in the database
        if err := h.db.CreateAuction(auction); err != nil </span><span class="cov0" title="0">{
                h.logger.Printf("Error creating auction: %v", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create auction"})
                return
        }</span>

        <span class="cov8" title="1">h.logger.Printf("Auction created successfully with ID: %s", auctionID)

        // Return the created auction
        response := AuctionResponse{
                ID:            auction.ID,
                Title:         auction.Title,
                Status:        auction.AuctionStatus,
                CurrentRound:  auction.CurrentRound,
                StartingPrice: auction.StartingPrice,
                PriceStep:     auction.PriceStep,
                HighestBid:    auction.HighestBid,
                HighestBidder: auction.HighestBidder,
                CreatedAt:     auction.CreatedAt,
                Bidders:       auction.Bidders,
        }

        c.JSON(http.StatusCreated, gin.H{
                "data":    response,
                "message": "Auction created successfully",
        })</span>
}

// GetAllAuctions returns all auctions
func (h *AuctionHandlers) GetAllAuctions(c *gin.Context) <span class="cov8" title="1">{
        auctions, err := h.db.GetAllAuctions()
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Printf("Error getting all auctions: %v", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get auctions"})
                return
        }</span>

        // Convert to response format
        <span class="cov8" title="1">var response []AuctionResponse
        for _, auction := range auctions </span><span class="cov8" title="1">{
                response = append(response, AuctionResponse{
                        ID:            auction.ID,
                        Title:         auction.Title,
                        Status:        auction.AuctionStatus,
                        CurrentRound:  auction.CurrentRound,
                        StartingPrice: auction.StartingPrice,
                        PriceStep:     auction.PriceStep,
                        HighestBid:    auction.HighestBid,
                        HighestBidder: auction.HighestBidder,
                        CreatedAt:     auction.CreatedAt,
                        Bidders:       auction.Bidders,
                })
        }</span>

        <span class="cov8" title="1">h.logger.Printf("Retrieved %d auctions", len(response))
        c.JSON(http.StatusOK, gin.H{"data": response})</span>
}

// GetAuction returns a specific auction by ID
func (h *AuctionHandlers) GetAuction(c *gin.Context) <span class="cov8" title="1">{
        auctionID := c.Param("id")
        if auctionID == "" </span><span class="cov0" title="0">{
                h.logger.Printf("Auction ID is required")
                c.JSON(http.StatusBadRequest, gin.H{"error": "Auction ID is required"})
                return
        }</span>

        <span class="cov8" title="1">h.logger.Printf("Getting auction with ID: %s", auctionID)

        auction, err := h.db.GetAuction(auctionID)
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Printf("Error getting auction: %v", err)
                c.JSON(http.StatusNotFound, gin.H{"error": "Auction not found"})
                return
        }</span>

        <span class="cov8" title="1">response := AuctionResponse{
                ID:            auction.ID,
                Title:         auction.Title,
                Status:        auction.AuctionStatus,
                CurrentRound:  auction.CurrentRound,
                StartingPrice: auction.StartingPrice,
                PriceStep:     auction.PriceStep,
                HighestBid:    auction.HighestBid,
                HighestBidder: auction.HighestBidder,
                CreatedAt:     auction.CreatedAt,
                Bidders:       auction.Bidders,
        }

        h.logger.Printf("Retrieved auction: %s - %s", auction.ID, auction.Title)
        c.JSON(http.StatusOK, gin.H{"data": response})</span>
}

// ExportAuctionData exports auction data by ID
func (h *AuctionHandlers) ExportAuctionData(c *gin.Context) <span class="cov8" title="1">{
        auctionID := c.Param("id")
        if auctionID == "" </span><span class="cov0" title="0">{
                h.logger.Printf("Auction ID is required")
                c.JSON(http.StatusBadRequest, gin.H{"error": "Auction ID is required"})
                return
        }</span>

        <span class="cov8" title="1">h.logger.Printf("Exporting data for auction with ID: %s", auctionID)

        // Get export data
        exportData, err := h.db.ExportAuctionData(auctionID)
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Printf("Error exporting auction data: %v", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">h.logger.Printf("Successfully exported data for auction: %s", auctionID)
        c.JSON(http.StatusOK, gin.H{"data": exportData})</span>
}

// StartAuction starts an auction by changing its status to inProgress
func (h *AuctionHandlers) StartAuction(c *gin.Context) <span class="cov8" title="1">{
        auctionID := c.Param("id")
        if auctionID == "" </span><span class="cov0" title="0">{
                h.logger.Printf("Auction ID is required")
                c.JSON(http.StatusBadRequest, gin.H{"error": "Auction ID is required"})
                return
        }</span>

        <span class="cov8" title="1">h.logger.Printf("Starting auction with ID: %s", auctionID)

        // Get the auction
        auction, err := h.db.GetAuction(auctionID)
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Printf("Error getting auction: %v", err)
                c.JSON(http.StatusNotFound, gin.H{"error": "Auction not found"})
                return
        }</span>

        // Check if the auction is already started
        <span class="cov8" title="1">if auction.AuctionStatus != "notStarted" </span><span class="cov8" title="1">{
                h.logger.Printf("Cannot start auction: already in progress or completed")
                c.JSON(http.StatusBadRequest, gin.H{"error": "Auction is already in progress or completed"})
                return
        }</span>

        // Update auction status to inProgress
        <span class="cov8" title="1">auction.AuctionStatus = "inProgress"
        auction.CurrentRound = 1

        // Save the updated auction
        if err := h.db.UpdateAuction(auctionID, auction); err != nil </span><span class="cov0" title="0">{
                h.logger.Printf("Error updating auction: %v", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to start auction"})
                return
        }</span>

        <span class="cov8" title="1">h.logger.Printf("Auction started successfully: %s", auctionID)
        c.JSON(http.StatusOK, gin.H{"message": "Auction started successfully"})</span>
}

// EndAuction ends an auction by changing its status to completed
func (h *AuctionHandlers) EndAuction(c *gin.Context) <span class="cov8" title="1">{
        auctionID := c.Param("id")
        if auctionID == "" </span><span class="cov0" title="0">{
                h.logger.Printf("Auction ID is required")
                c.JSON(http.StatusBadRequest, gin.H{"error": "Auction ID is required"})
                return
        }</span>

        <span class="cov8" title="1">h.logger.Printf("Ending auction with ID: %s", auctionID)

        // Get the auction
        auction, err := h.db.GetAuction(auctionID)
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Printf("Error getting auction: %v", err)
                c.JSON(http.StatusNotFound, gin.H{"error": "Auction not found"})
                return
        }</span>

        // Check if the auction is in progress
        <span class="cov8" title="1">if auction.AuctionStatus != "inProgress" </span><span class="cov8" title="1">{
                h.logger.Printf("Cannot end auction: not in progress")
                c.JSON(http.StatusBadRequest, gin.H{"error": "Auction is not in progress"})
                return
        }</span>

        // Update auction status to completed
        <span class="cov8" title="1">auction.AuctionStatus = "completed"

        // Save the updated auction
        if err := h.db.UpdateAuction(auctionID, auction); err != nil </span><span class="cov0" title="0">{
                h.logger.Printf("Error updating auction: %v", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to end auction"})
                return
        }</span>

        <span class="cov8" title="1">h.logger.Printf("Auction ended successfully: %s", auctionID)
        c.JSON(http.StatusOK, gin.H{"message": "Auction ended successfully"})</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package handlers

import (
        "fmt"
        "log"
        "net/http"
        "strconv"
        "strings"

        "github.com/gin-gonic/gin"

        "auction/internal/database"
        "auction/internal/models"
        "auction/internal/services"
)

type BidderHandlers struct {
        db           database.Database
        logger       *log.Logger
        excelService services.ExcelService
}

func NewBidderHandlers(db database.Database, logger *log.Logger, excelService services.ExcelService) *BidderHandlers <span class="cov8" title="1">{
        return &amp;BidderHandlers{
                db:           db,
                logger:       logger,
                excelService: excelService,
        }
}</span>

// GetBidders returns all bidders
func (h *BidderHandlers) GetBidders(c *gin.Context) <span class="cov8" title="1">{
        // Log request
        h.logger.Printf("Received request to get bidders")

        bidders, err := h.db.GetBidders()
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Printf("Error getting bidders: %v", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get bidders"})
                return
        }</span>

        // Only log the count, not the full details
        <span class="cov8" title="1">if len(bidders) == 0 </span><span class="cov8" title="1">{
                h.logger.Printf("No bidders found")
        }</span> else<span class="cov8" title="1"> {
                h.logger.Printf("Found %d bidders", len(bidders))
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "data":  bidders,
                "count": len(bidders),
        })</span>
}

// AddBidder adds a new bidder
func (h *BidderHandlers) AddBidder(c *gin.Context) <span class="cov8" title="1">{
        var request struct {
                Name    string `json:"name" binding:"required"`
                ID      string `json:"id" binding:"required"`
                Address string `json:"address"`
        }

        if err := c.ShouldBindJSON(&amp;request); err != nil </span><span class="cov8" title="1">{
                h.logger.Printf("Error binding JSON: %v", err)
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
                return
        }</span>

        <span class="cov8" title="1">bidders, err := h.db.GetBidders()
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Printf("Error getting bidders: %v", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get bidders"})
                return
        }</span>

        // Validate required fields
        <span class="cov8" title="1">if request.Name == "" || request.Address == "" </span><span class="cov0" title="0">{
                h.logger.Printf("Missing required fields: name or address")
                c.JSON(http.StatusBadRequest, gin.H{"error": "Name and Address are required fields"})
                return
        }</span>

        // Auto-generate ID if not provided or empty
        <span class="cov8" title="1">if request.ID == "" </span><span class="cov0" title="0">{
                nextID := 1
                for _, p := range bidders </span><span class="cov0" title="0">{
                        if id, err := strconv.Atoi(p.ID); err == nil </span><span class="cov0" title="0">{
                                if id &gt;= nextID </span><span class="cov0" title="0">{
                                        nextID = id + 1
                                }</span>
                        }
                }
                <span class="cov0" title="0">request.ID = strconv.Itoa(nextID)</span>
        }

        <span class="cov8" title="1">bidders = append(bidders, models.Bidder{
                ID:      request.ID,
                Name:    request.Name,
                Address: request.Address,
        })

        if err := h.db.SetBidders(bidders); err != nil </span><span class="cov0" title="0">{
                h.logger.Printf("Error saving bidder: %v", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to save bidder"})
                return
        }</span>

        <span class="cov8" title="1">if err := h.db.SaveData(); err != nil </span><span class="cov0" title="0">{
                h.logger.Printf("Error saving data: %v", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to save data"})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusCreated, gin.H{
                "data":    request,
                "message": "Bidder added successfully",
        })</span>
}

// DeleteBidder deletes a bidder by ID
func (h *BidderHandlers) DeleteBidder(c *gin.Context) <span class="cov8" title="1">{
        id := c.Param("id")
        if id == "" </span><span class="cov0" title="0">{
                h.logger.Printf("Error: No bidder ID provided")
                c.JSON(http.StatusBadRequest, gin.H{"error": "No bidder ID provided"})
                return
        }</span>

        <span class="cov8" title="1">bidders, err := h.db.GetBidders()
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Printf("Error getting bidders: %v", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get bidders"})
                return
        }</span>

        <span class="cov8" title="1">var newBidders []models.Bidder
        found := false

        for _, p := range bidders </span><span class="cov8" title="1">{
                if p.ID != id </span><span class="cov8" title="1">{
                        newBidders = append(newBidders, p)
                }</span> else<span class="cov8" title="1"> {
                        found = true
                }</span>
        }

        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                h.logger.Printf("Bidder not found: %s", id)
                c.JSON(http.StatusNotFound, gin.H{"error": "Bidder not found"})
                return
        }</span>

        <span class="cov8" title="1">if err := h.db.SetBidders(newBidders); err != nil </span><span class="cov0" title="0">{
                h.logger.Printf("Error setting bidders: %v", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update bidders"})
                return
        }</span>

        <span class="cov8" title="1">if err := h.db.SaveData(); err != nil </span><span class="cov0" title="0">{
                h.logger.Printf("Error saving data: %v", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to save data"})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"message": "Bidder deleted successfully"})</span>
}

// UploadExcelFile processes an uploaded Excel file and extracts bidder information
func (h *BidderHandlers) UploadExcelFile(c *gin.Context) <span class="cov8" title="1">{
        // Log headers for debugging
        h.logger.Printf("Content-Type: %s", c.GetHeader("Content-Type"))
        h.logger.Printf("Processing file upload request")

        // Check content type
        contentType := c.GetHeader("Content-Type")
        if !strings.Contains(contentType, "multipart/form-data") </span><span class="cov8" title="1">{
                h.logger.Printf("Invalid Content-Type: %s, expected multipart/form-data", contentType)
                c.JSON(http.StatusBadRequest, gin.H{"error": "Request Content-Type must be multipart/form-data"})
                return
        }</span>

        // Get file from request
        <span class="cov0" title="0">file, header, err := c.Request.FormFile("file")
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Printf("No file uploaded or error getting file: %v", err)
                c.JSON(http.StatusBadRequest, gin.H{"error": "No file uploaded or invalid file"})
                return
        }</span>
        <span class="cov0" title="0">defer file.Close()

        h.logger.Printf("File uploaded: %s, size: %d bytes", header.Filename, header.Size)

        // Process Excel file to get list of bidders
        bidders, err := h.excelService.ProcessExcelFile(file)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Printf("Error processing Excel file: %v", err)
                c.JSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("Failed to process Excel file: %v", err)})
                return
        }</span>

        <span class="cov0" title="0">if len(bidders) == 0 </span><span class="cov0" title="0">{
                h.logger.Printf("No bidders found in Excel file")
                c.JSON(http.StatusBadRequest, gin.H{"error": "No bidders found in Excel file"})
                return
        }</span>

        <span class="cov0" title="0">h.logger.Printf("Parsed %d bidders from Excel file", len(bidders))

        // Return the parsed bidders directly to the client
        h.logger.Printf("Returning response with %d entries", len(bidders))
        c.JSON(http.StatusOK, gin.H{
                "message": "File processed successfully",
                "data":    bidders,
                "count":   len(bidders),
        })</span>
}

// SetBidders replaces all bidders with a new list
func (h *BidderHandlers) SetBidders(c *gin.Context) <span class="cov8" title="1">{
        var request struct {
                Bidders []models.Bidder `json:"bidders" binding:"required"`
        }

        if err := c.ShouldBindJSON(&amp;request); err != nil </span><span class="cov8" title="1">{
                h.logger.Printf("Error binding JSON: %v", err)
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
                return
        }</span>

        // No need to get existing bidders since we're replacing them all
        <span class="cov8" title="1">if err := h.db.SetBidders(request.Bidders); err != nil </span><span class="cov0" title="0">{
                h.logger.Printf("Error setting bidders: %v", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update bidders"})
                return
        }</span>

        <span class="cov8" title="1">if err := h.db.SaveData(); err != nil </span><span class="cov0" title="0">{
                h.logger.Printf("Error saving data: %v", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to save data"})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "message": "Bidders set successfully",
                "data":    request.Bidders,
        })</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package middleware

import (
        "log"
        "runtime/debug"
        "time"

        "github.com/gin-gonic/gin"
)

// LoggingMiddleware logs HTTP requests and responses
func LoggingMiddleware(logger *log.Logger) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                start := time.Now()
                path := c.Request.URL.Path
                rawQuery := c.Request.URL.RawQuery

                logger.Printf("Request: %s %s%s", c.Request.Method, path, func() string </span><span class="cov8" title="1">{
                        if rawQuery != "" </span><span class="cov8" title="1">{
                                return "?" + rawQuery
                        }</span>
                        <span class="cov8" title="1">return ""</span>
                }())

                // Process request
                <span class="cov8" title="1">c.Next()

                // After request
                latency := time.Since(start)
                logger.Printf("Response: %s %s - %d in %v",
                        c.Request.Method, path, c.Writer.Status(), latency)</span>
        }
}

// RecoveryMiddleware recovers from panics
func RecoveryMiddleware(logger *log.Logger) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                defer func() </span><span class="cov8" title="1">{
                        if err := recover(); err != nil </span><span class="cov8" title="1">{
                                logger.Printf("Panic recovered: %v\nStack trace: %s", err, debug.Stack())
                                c.AbortWithStatus(500)
                        }</span>
                }()
                <span class="cov8" title="1">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package middleware

import (
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/ulule/limiter/v3"
        "github.com/ulule/limiter/v3/drivers/store/memory"
)

// RateLimiterMiddleware creates a middleware for rate limiting
func RateLimiterMiddleware(maxRequests int, period time.Duration) gin.HandlerFunc <span class="cov8" title="1">{
        rate := limiter.Rate{
                Period: period,
                Limit:  int64(maxRequests),
        }

        store := memory.NewStore()
        instance := limiter.New(store, rate)

        return func(c *gin.Context) </span><span class="cov8" title="1">{
                ip := c.ClientIP()
                limiterCtx, err := instance.Get(c, ip)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "error": "Error checking rate limit",
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov8" title="1">if limiterCtx.Reached </span><span class="cov8" title="1">{
                        c.JSON(http.StatusTooManyRequests, gin.H{
                                "error": "Rate limit exceeded",
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov8" title="1">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package config

import (
        "os"
        "time"
)

// Config holds all configuration settings
type Config struct {
        Server    ServerConfig
        Database  DatabaseConfig
        CORS      CORSConfig
        RateLimit RateLimitConfig
}

// ServerConfig holds server-related settings
type ServerConfig struct {
        Port string
}

// DatabaseConfig holds database-related settings
type DatabaseConfig struct {
        DataDir  string
        DataFile string
}

// CORSConfig holds CORS-related settings
type CORSConfig struct {
        AllowOrigins []string
        AllowMethods []string
        AllowHeaders []string
}

// RateLimitConfig holds rate limiting settings
type RateLimitConfig struct {
        MaxRequests int
        Period      time.Duration
}

// LoadConfig loads configuration from environment variables
func LoadConfig() *Config <span class="cov8" title="1">{
        return &amp;Config{
                Server: ServerConfig{
                        Port: getEnv("PORT", "8080"),
                },
                Database: DatabaseConfig{
                        DataDir:  getEnv("DATA_DIR", "data"),
                        DataFile: getEnv("DATA_FILE", "auction_data.json"),
                },
                CORS: CORSConfig{
                        AllowOrigins: []string{getEnv("CORS_ORIGIN", "http://localhost:3000")},
                        AllowMethods: []string{"GET", "POST", "DELETE", "OPTIONS", "PUT"},
                        AllowHeaders: []string{"Origin", "Content-Type"},
                },
                RateLimit: RateLimitConfig{
                        MaxRequests: 100,              // 100 requests
                        Period:      60 * time.Second, // per minute
                },
        }
}</span>

// getEnv gets an environment variable or returns a default value
func getEnv(key, defaultValue string) string <span class="cov8" title="1">{
        if value := os.Getenv(key); value != "" </span><span class="cov8" title="1">{
                return value
        }</span>
        <span class="cov8" title="1">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package database

import (
        "encoding/json"
        "fmt"
        "log"
        "os"
        "path/filepath"
        "sync"
        "time"

        "auction/internal/models"
)

// TinyDB implements a simple JSON file-based database
type TinyDB struct {
        dataDir     string
        dataFile    string
        logger      *log.Logger
        mu          sync.RWMutex
        auctionData *models.AuctionData
        initialized bool
}

// NewTinyDB creates a new instance of TinyDB
func NewTinyDB(dataDir string, logger *log.Logger) (*TinyDB, error) <span class="cov8" title="1">{
        // Ensure data directory exists
        if err := os.MkdirAll(dataDir, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create data directory: %v", err)
        }</span>

        <span class="cov8" title="1">return &amp;TinyDB{
                dataDir:  dataDir,
                dataFile: filepath.Join(dataDir, "auction_data.json"),
                logger:   logger,
                auctionData: &amp;models.AuctionData{
                        Auctions:       make(map[string]*models.Auction),
                        CurrentAuction: "",
                },
                initialized: false,
        }, nil</span>
}

// Close implements Database.Close
func (t *TinyDB) Close() error <span class="cov8" title="1">{
        // Save data before closing
        return t.SaveData()
}</span>

// SaveData implements Database.SaveData
func (t *TinyDB) SaveData() error <span class="cov8" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()

        return t.saveDataNoLock()
}</span>

// saveDataNoLock saves data to file without acquiring the lock
func (t *TinyDB) saveDataNoLock() error <span class="cov8" title="1">{
        // Marshal data to JSON
        data, err := json.MarshalIndent(t.auctionData, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal auction data: %v", err)
        }</span>

        // Write to temporary file first
        <span class="cov8" title="1">tempFile := t.dataFile + ".tmp"
        if err := os.WriteFile(tempFile, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write to temporary file: %v", err)
        }</span>

        // Rename temporary file to actual file (atomic operation)
        <span class="cov8" title="1">if err := os.Rename(tempFile, t.dataFile); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to rename temporary file: %v", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// loadData loads data from file
func (t *TinyDB) loadData() error <span class="cov8" title="1">{
        // Check if file exists
        if _, err := os.Stat(t.dataFile); os.IsNotExist(err) </span><span class="cov0" title="0">{
                // File doesn't exist, use default data
                t.initialized = true
                return nil
        }</span>

        // Read file
        <span class="cov8" title="1">data, err := os.ReadFile(t.dataFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read data file: %v", err)
        }</span>

        // Unmarshal data
        <span class="cov8" title="1">if len(data) &gt; 0 </span><span class="cov8" title="1">{
                err = json.Unmarshal(data, t.auctionData)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to unmarshal auction data: %v", err)
                }</span>
        }

        // Initialize auctions map if it's nil
        <span class="cov8" title="1">if t.auctionData.Auctions == nil </span><span class="cov0" title="0">{
                t.auctionData.Auctions = make(map[string]*models.Auction)
        }</span>

        <span class="cov8" title="1">t.initialized = true
        return nil</span>
}

// Initialize implements Database.Initialize
func (t *TinyDB) Initialize() error <span class="cov8" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()

        // Check if file exists
        if _, err := os.Stat(t.dataFile); os.IsNotExist(err) </span><span class="cov8" title="1">{
                // File doesn't exist, create it with default data
                if err := t.saveDataNoLock(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to initialize database: %v", err)
                }</span>
                <span class="cov8" title="1">t.initialized = true
                return nil</span>
        }

        // File exists, load data
        <span class="cov8" title="1">if err := t.loadData(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize database: %v", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetBidders retrieves all bidders from all auctions
func (t *TinyDB) GetBidders() ([]models.Bidder, error) <span class="cov8" title="1">{
        t.mu.RLock()
        defer t.mu.RUnlock()

        // Load data if not initialized
        if !t.initialized </span><span class="cov0" title="0">{
                if err := t.loadData(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // If current auction is set, return bidders from that auction
        <span class="cov8" title="1">if t.auctionData.CurrentAuction != "" </span><span class="cov8" title="1">{
                if auction, exists := t.auctionData.Auctions[t.auctionData.CurrentAuction]; exists </span><span class="cov8" title="1">{
                        return auction.Bidders, nil
                }</span>
        }

        // Otherwise, return empty list
        <span class="cov8" title="1">return []models.Bidder{}, nil</span>
}

// SetBidders sets bidders for the current auction
func (t *TinyDB) SetBidders(bidders []models.Bidder) error <span class="cov8" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()

        // Load data if not initialized
        if !t.initialized </span><span class="cov0" title="0">{
                if err := t.loadData(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // If current auction is set, update bidders for that auction
        <span class="cov8" title="1">if t.auctionData.CurrentAuction != "" </span><span class="cov8" title="1">{
                if auction, exists := t.auctionData.Auctions[t.auctionData.CurrentAuction]; exists </span><span class="cov8" title="1">{
                        auction.Bidders = bidders
                        return t.saveDataNoLock()
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("current auction not found")</span>
        }

        <span class="cov8" title="1">return fmt.Errorf("no current auction set")</span>
}

// GetAllAuctions implements Database.GetAllAuctions
func (t *TinyDB) GetAllAuctions() (map[string]*models.Auction, error) <span class="cov8" title="1">{
        t.mu.RLock()
        defer t.mu.RUnlock()

        // Load data if not initialized
        if !t.initialized </span><span class="cov0" title="0">{
                if err := t.loadData(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">return t.auctionData.Auctions, nil</span>
}

// GetAuction implements Database.GetAuction
func (t *TinyDB) GetAuction(id string) (*models.Auction, error) <span class="cov8" title="1">{
        t.mu.RLock()
        defer t.mu.RUnlock()

        // Load data if not initialized
        if !t.initialized </span><span class="cov0" title="0">{
                if err := t.loadData(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // Check if auction exists
        <span class="cov8" title="1">auction, exists := t.auctionData.Auctions[id]
        if !exists </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("auction with ID %s not found", id)
        }</span>

        <span class="cov8" title="1">return auction, nil</span>
}

// CreateAuction implements Database.CreateAuction
func (t *TinyDB) CreateAuction(auction *models.Auction) error <span class="cov8" title="1">{
        if auction == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("cannot create nil auction")
        }</span>

        <span class="cov8" title="1">t.mu.Lock()
        defer t.mu.Unlock()

        // Load data if not initialized
        if !t.initialized </span><span class="cov0" title="0">{
                if err := t.loadData(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Check if auction ID already exists
        <span class="cov8" title="1">if _, exists := t.auctionData.Auctions[auction.ID]; exists </span><span class="cov8" title="1">{
                return fmt.Errorf("auction with ID %s already exists", auction.ID)
        }</span>

        // Add auction to map
        <span class="cov8" title="1">t.auctionData.Auctions[auction.ID] = auction

        // Save to file
        return t.saveDataNoLock()</span>
}

// UpdateAuction implements Database.UpdateAuction
func (t *TinyDB) UpdateAuction(id string, auction *models.Auction) error <span class="cov8" title="1">{
        if auction == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("cannot update with nil auction")
        }</span>

        <span class="cov8" title="1">t.mu.Lock()
        defer t.mu.Unlock()

        // Load data if not initialized
        if !t.initialized </span><span class="cov0" title="0">{
                if err := t.loadData(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Check if auction exists
        <span class="cov8" title="1">if _, exists := t.auctionData.Auctions[id]; !exists </span><span class="cov8" title="1">{
                return fmt.Errorf("auction with ID %s not found", id)
        }</span>

        // Update auction
        <span class="cov8" title="1">t.auctionData.Auctions[id] = auction

        // Save to file
        return t.saveDataNoLock()</span>
}

// DeleteAuction implements Database.DeleteAuction
func (t *TinyDB) DeleteAuction(id string) error <span class="cov8" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()

        // Load data if not initialized
        if !t.initialized </span><span class="cov0" title="0">{
                if err := t.loadData(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Check if auction exists
        <span class="cov8" title="1">if _, exists := t.auctionData.Auctions[id]; !exists </span><span class="cov8" title="1">{
                return fmt.Errorf("auction with ID %s not found", id)
        }</span>

        // Delete auction
        <span class="cov8" title="1">delete(t.auctionData.Auctions, id)

        // Save to file
        return t.saveDataNoLock()</span>
}

// ExportAuctionData implements Database.ExportAuctionData
func (t *TinyDB) ExportAuctionData(id string) (*models.ExportData, error) <span class="cov8" title="1">{
        t.mu.RLock()
        defer t.mu.RUnlock()

        // Load data if not initialized
        if !t.initialized </span><span class="cov0" title="0">{
                if err := t.loadData(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // Check if auction exists
        <span class="cov8" title="1">auction, exists := t.auctionData.Auctions[id]
        if !exists </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("auction with ID %s not found", id)
        }</span>

        // Check if auction is completed
        <span class="cov8" title="1">if auction.AuctionStatus != "completed" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("cannot export data for auction that is not completed")
        }</span>

        // Find winner information
        <span class="cov8" title="1">var winnerName string
        for _, bidder := range auction.Bidders </span><span class="cov8" title="1">{
                if bidder.ID == auction.HighestBidder </span><span class="cov8" title="1">{
                        winnerName = bidder.Name
                        break</span>
                }
        }

        // Create export data
        <span class="cov8" title="1">exportData := &amp;models.ExportData{
                AuctionID:     auction.ID,
                Title:         auction.Title,
                StartingPrice: auction.StartingPrice,
                PriceStep:     auction.PriceStep,
                TotalBids:     len(auction.BidHistory),
                BidHistory:    auction.BidHistory,
                WinnerID:      auction.HighestBidder,
                WinnerName:    winnerName,
                WinningBid:    auction.HighestBid,
                EndTime:       time.Now(), // Ideally this would be stored in the auction data
        }

        return exportData, nil</span>
}

// Ensure TinyDB implements Database interface
var _ Database = (*TinyDB)(nil)
</pre>
		
		<pre class="file" id="file6" style="display: none">package models

// ErrorNotFound represents an error when a resource is not found
type ErrorNotFound struct {
        Message string
}

// Error returns the error message
func (e *ErrorNotFound) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

// ErrorValidation represents an error during validation
type ErrorValidation struct {
        Message string
}

// Error returns the error message
func (e *ErrorValidation) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

// ErrorDuplicate represents an error when a duplicate resource is detected
type ErrorDuplicate struct {
        Message string
}

// Error returns the error message
func (e *ErrorDuplicate) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

// ErrorDatabase represents a general database error
type ErrorDatabase struct {
        Message string
}

// Error returns the error message
func (e *ErrorDatabase) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package services

import (
        "fmt"
        "io"
        "log"
        "os"

        "auction/internal/models"

        "github.com/xuri/excelize/v2"
)

// ExcelService defines the interface for Excel file processing
type ExcelService interface {
        ProcessExcelFile(file io.Reader) ([]models.Bidder, error)
}

// excelService implements the ExcelService interface
type excelService struct {
        logger *log.Logger
}

// NewExcelService creates a new instance of ExcelService
func NewExcelService(logger *log.Logger) ExcelService <span class="cov8" title="1">{
        return &amp;excelService{
                logger: logger,
        }
}</span>

// ProcessExcelFile processes an Excel file and extracts bidder information
func (s *excelService) ProcessExcelFile(file io.Reader) ([]models.Bidder, error) <span class="cov8" title="1">{
        // Create a temporary file to store the uploaded Excel file
        tempFile, err := os.CreateTemp("", "upload-*.xlsx")
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Error creating temp file: %v", err)
                return nil, fmt.Errorf("error creating temp file: %w", err)
        }</span>

        // Copy the file data to the temp file
        <span class="cov8" title="1">_, err = io.Copy(tempFile, file)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Error copying file data: %v", err)
                os.Remove(tempFile.Name())
                return nil, fmt.Errorf("error copying file data: %w", err)
        }</span>

        // Close the file to ensure all data is written
        <span class="cov8" title="1">tempFile.Close()

        s.logger.Printf("Temporary file created: %s", tempFile.Name())

        // Open the Excel file
        xlsx, err := excelize.OpenFile(tempFile.Name())
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Printf("Error opening Excel file: %v", err)
                os.Remove(tempFile.Name())
                return nil, fmt.Errorf("error opening Excel file: %w", err)
        }</span>
        <span class="cov8" title="1">defer xlsx.Close()

        s.logger.Printf("Excel file opened successfully")

        // Get all sheet names
        sheetNames := xlsx.GetSheetList()
        if len(sheetNames) == 0 </span><span class="cov0" title="0">{
                s.logger.Printf("No sheets found in Excel file")
                os.Remove(tempFile.Name())
                return nil, fmt.Errorf("no sheets found in Excel file")
        }</span>

        <span class="cov8" title="1">s.logger.Printf("Found sheets: %v", sheetNames)

        // Try to find the "Đủ ĐK" sheet first
        sheetName := sheetNames[0] // Default to first sheet
        for _, name := range sheetNames </span><span class="cov8" title="1">{
                if name == "Đủ ĐK" </span><span class="cov8" title="1">{
                        sheetName = name
                        break</span>
                }
        }

        // Get all the rows in the sheet
        <span class="cov8" title="1">rows, err := xlsx.GetRows(sheetName)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Error reading rows from sheet %s: %v", sheetName, err)
                os.Remove(tempFile.Name())
                return nil, fmt.Errorf("error reading rows from sheet %s: %w", sheetName, err)
        }</span>

        <span class="cov8" title="1">s.logger.Printf("Reading from sheet: %s", sheetName)

        var bidders []models.Bidder
        startRow := 11 // Default for "Đủ ĐK" sheet
        if sheetName != "Đủ ĐK" </span><span class="cov8" title="1">{
                startRow = 1 // For other sheets, start from first row
        }</span>

        // Process rows
        <span class="cov8" title="1">for i := startRow; i &lt; len(rows); i++ </span><span class="cov8" title="1">{
                row := rows[i]
                if len(row) &gt;= 3 &amp;&amp; row[0] != "" &amp;&amp; row[1] != "" &amp;&amp; row[2] != "" </span><span class="cov8" title="1">{
                        bidder := models.Bidder{
                                ID:      row[0],
                                Name:    row[1],
                                Address: row[2],
                        }
                        bidders = append(bidders, bidder)
                        s.logger.Printf("Added bidder: ID=%s, Name=%s", bidder.ID, bidder.Name)
                }</span>
        }

        // Clean up the temp file
        <span class="cov8" title="1">os.Remove(tempFile.Name())
        s.logger.Printf("Cleaned up temporary file: %s", tempFile.Name())

        if len(bidders) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no valid bidders found in Excel file")
        }</span>

        <span class="cov8" title="1">s.logger.Printf("Successfully processed %d bidders from Excel file", len(bidders))
        return bidders, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package main

import (
        "log"
        "os"
        "time"

        "github.com/gin-contrib/cors"
        "github.com/gin-gonic/gin"

        "auction/api/handlers"
        "auction/internal/database"
        "auction/internal/services"
)

type App struct {
        router *gin.Engine
        db     database.Database
        logger *log.Logger
}

func NewApp() (*App, error) <span class="cov0" title="0">{
        // Set up logger
        logger := log.New(os.Stdout, "[AUCTION] ", log.LstdFlags)

        // Create data directory if it doesn't exist
        dataDir := "data"
        if err := os.MkdirAll(dataDir, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Initialize TinyDB (JSON file-based database)
        <span class="cov0" title="0">db, err := database.NewTinyDB(dataDir, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Initialize database with default data if needed
        <span class="cov0" title="0">if err := db.Initialize(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create router
        <span class="cov0" title="0">router := gin.Default()

        // Configure CORS - Allow specific origins with credentials
        config := cors.Config{
                AllowOrigins:     []string{"http://127.0.0.1:5500", "http://localhost:5500", "http://localhost:8080"},
                AllowMethods:     []string{"GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"},
                AllowHeaders:     []string{"Origin", "Content-Type", "Accept", "Authorization", "X-Requested-With"},
                ExposeHeaders:    []string{"Content-Length"},
                AllowCredentials: true,
                MaxAge:           12 * time.Hour,
        }
        router.Use(cors.New(config))

        return &amp;App{
                router: router,
                db:     db,
                logger: logger,
        }, nil</span>
}

func (a *App) Initialize() error <span class="cov0" title="0">{
        // Initialize services
        excelService := services.NewExcelService(a.logger)

        // Create API handlers
        auctionHandlers := handlers.NewAuctionHandlers(a.db, a.logger)
        bidderHandlers := handlers.NewBidderHandlers(a.db, a.logger, excelService)

        // Group API routes
        api := a.router.Group("/api/v1")
        </span><span class="cov0" title="0">{
                // Multi-auction routes
                api.POST("/auctions", auctionHandlers.CreateAuction)
                api.GET("/auctions", auctionHandlers.GetAllAuctions)
                api.GET("/auctions/:id", auctionHandlers.GetAuction)
                api.GET("/auction/export/:id", auctionHandlers.ExportAuctionData)
                api.PUT("/auctions/:id/start", auctionHandlers.StartAuction)
                api.PUT("/auctions/:id/end", auctionHandlers.EndAuction)

                // Bidder routes
                api.GET("/bidders", bidderHandlers.GetBidders)
                api.POST("/bidders", bidderHandlers.AddBidder)
                api.PUT("/bidders", bidderHandlers.SetBidders)
                api.DELETE("/bidders/:id", bidderHandlers.DeleteBidder)
                api.POST("/bidders/import", bidderHandlers.UploadExcelFile)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (a *App) Run() error <span class="cov0" title="0">{
        return a.router.Run(":8080")
}</span>

func (a *App) Close() error <span class="cov0" title="0">{
        return a.db.Close()
}</span>

func main() <span class="cov0" title="0">{
        app, err := NewApp()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">defer app.Close()

        if err := app.Initialize(); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">if err := app.Run(); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package tests

import (
        "github.com/stretchr/testify/mock"

        "auction/internal/models"
)

// MockDatabase is a mock implementation of database.Database
type MockDatabase struct {
        mock.Mock
}

// Initialize implements the Initialize method of the Database interface
func (m *MockDatabase) Initialize() error <span class="cov0" title="0">{
        args := m.Called()
        return args.Error(0)
}</span>

// Close implements the Close method of the Database interface
func (m *MockDatabase) Close() error <span class="cov0" title="0">{
        args := m.Called()
        return args.Error(0)
}</span>

// SaveData implements the SaveData method of the Database interface
func (m *MockDatabase) SaveData() error <span class="cov8" title="1">{
        args := m.Called()
        return args.Error(0)
}</span>

// GetBidders retrieves bidders from the database
func (m *MockDatabase) GetBidders() ([]models.Bidder, error) <span class="cov8" title="1">{
        args := m.Called()
        if args.Get(0) == nil </span><span class="cov8" title="1">{
                return nil, args.Error(1)
        }</span>
        <span class="cov8" title="1">return args.Get(0).([]models.Bidder), args.Error(1)</span>
}

// SetBidders updates bidders in the database
func (m *MockDatabase) SetBidders(bidders []models.Bidder) error <span class="cov8" title="1">{
        args := m.Called(bidders)
        return args.Error(0)
}</span>

// GetAllAuctions retrieves all auctions from the database
func (m *MockDatabase) GetAllAuctions() (map[string]*models.Auction, error) <span class="cov0" title="0">{
        args := m.Called()
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(map[string]*models.Auction), args.Error(1)</span>
}

// GetAuction retrieves a specific auction by ID
func (m *MockDatabase) GetAuction(id string) (*models.Auction, error) <span class="cov8" title="1">{
        args := m.Called(id)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov8" title="1">return args.Get(0).(*models.Auction), args.Error(1)</span>
}

// CreateAuction creates a new auction
func (m *MockDatabase) CreateAuction(auction *models.Auction) error <span class="cov0" title="0">{
        args := m.Called(auction)
        return args.Error(0)
}</span>

// UpdateAuction updates an existing auction
func (m *MockDatabase) UpdateAuction(id string, auction *models.Auction) error <span class="cov8" title="1">{
        args := m.Called(id, auction)
        return args.Error(0)
}</span>

// DeleteAuction deletes an auction
func (m *MockDatabase) DeleteAuction(id string) error <span class="cov0" title="0">{
        args := m.Called(id)
        return args.Error(0)
}</span>

// ExportAuctionData exports auction data
func (m *MockDatabase) ExportAuctionData(id string) (*models.ExportData, error) <span class="cov8" title="1">{
        args := m.Called(id)
        if args.Get(0) == nil </span><span class="cov8" title="1">{
                return nil, args.Error(1)
        }</span>
        <span class="cov8" title="1">return args.Get(0).(*models.ExportData), args.Error(1)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
